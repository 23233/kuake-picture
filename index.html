<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>夸克搜索影视多宫格图片编辑器</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 p-4">
<!-- 设置区域 - 修改为flex布局 -->
<div class="mb-4 flex space-x-4">
    <div class="flex-1">
        <label class="block text-sm font-medium text-gray-700">选择宫格数量:</label>
        <select id="gridSize" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500">
            <option value="4">4 x 4</option>
            <option value="3">3 x 3</option>
            <option value="2">2 x 2</option>
        </select>
    </div>
    <div class="flex-1">
        <label class="block text-sm font-medium text-gray-700">选择编辑模式:</label>
        <select id="editMode" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500">
            <option value="column">列复制（整列同步）</option>
            <option value="unique">格子唯一（每格独立）</option>
        </select>
    </div>
</div>

<!-- 关键词设置和历史记录区域 -->
<div class="mb-4 space-y-4">
    <div class="flex space-x-4">
        <div class="flex-1">
            <label class="block text-sm font-medium text-gray-700">夸克搜索关键词:</label>
            <input type="text" id="searchKeyword" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500" onchange="updateSearchKeyword(this.value)">
        </div>
        <div class="flex-1">
            <label class="block text-sm font-medium text-gray-700">水印Logo:</label>
            <div class="flex space-x-2">
                <input type="file" id="watermarkInput" accept="image/*" multiple class="hidden" onChange="handleWatermarkUpload(event)">
                <button onclick="document.getElementById('watermarkInput').click()" class="mt-1 px-3 py-1 bg-pink-500 text-white text-sm rounded hover:bg-pink-600">
                    上传水印
                </button>
            </div>
        </div>
    </div>

    <!-- 历史记录选择区域 -->
    <div>
        <div class="flex justify-between items-center mb-2">
            <label class="block text-sm font-medium text-gray-700">历史记录:</label>
            <button
                    onclick="randomCombineFromAllGroups()"
                    class="px-3 py-1 bg-pink-500 text-white text-sm rounded hover:bg-pink-600 flex items-center space-x-1"
            >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
                </svg>
                <span>随机组合</span>
            </button>
        </div>
        <div id="historyContainer" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-2">
            <!-- 历史记录将在这里动态生成 -->
        </div>
    </div>
</div>

<!-- 图片宫格容器 -->
<div id="gridContainer" class="grid bg-white">
    <!-- 动态生成的格子将插入这里 -->
</div>

<!-- 修改生成按钮区域 -->
<div class="mt-4 flex space-x-4">
    <button id="generateImage" class="px-4 py-2 bg-pink-500 text-white rounded-md hover:bg-pink-600">
        生成图片
    </button>
    <button id="generateCellImage" class="px-4 py-2 bg-pink-500 text-white rounded-md hover:bg-pink-600">
        导出格子图片
    </button>
</div>

<!-- 编辑模态框 -->
<div id="editModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-96">
        <h3 class="text-lg font-medium mb-4">编辑内容</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700">选择图片</label>
                <input type="file" accept="image/*" id="imageInput" class="mt-1">
                <div id="imagePreviewContainer" class="mt-2"></div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">剧名</label>
                <input type="text" id="titleInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">演员名称</label>
                <input type="text" id="actorInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">划重点</label>
                <input type="text" id="highlightInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
            </div>
            <div class="flex justify-end space-x-2">
                <button id="cancelEdit" class="px-4 py-2 border rounded-md">取消</button>
                <button id="saveEdit" class="px-4 py-2 bg-pink-500 text-white rounded-md">保存</button>
            </div>
        </div>
    </div>
</div>

<!-- 列选择模态框 -->
<div id="columnSelectModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-96">
        <h3 class="text-lg font-medium mb-4">选择要替换的列</h3>
        <div id="columnSelectContainer" class="grid grid-cols-4 gap-2 mb-4">
            <!-- 列选项将在这里动态生成 -->
        </div>
        <div class="flex justify-end space-x-2">
            <button onclick="closeColumnSelectModal()" class="px-4 py-2 border rounded-md">取消</button>
        </div>
    </div>
</div>

<!-- 修改列图片选择模态框为格子图片选择模态框 -->
<div id="cellImageModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-[30vw]">
        <h3 class="text-lg font-medium mb-4">选择要导出的格子</h3>
        <div id="cellImageSelectContainer" class="grid gap-2 mb-4">
            <!-- 格子选项将在这里动态生成 -->
        </div>
        <div class="flex justify-end space-x-2">
            <button onclick="closeCellImageModal()" class="px-4 py-2 border rounded-md">取消</button>
        </div>
    </div>
</div>

<!-- 添加格子选择模态框 -->
<div id="cellSelectModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-[30vw]">
        <h3 class="text-lg font-medium mb-4">选择要替换的格子</h3>
        <div id="cellSelectContainer" class="grid mb-4">
            <!-- 格子选项将在这里动态生成 -->
        </div>
        <div class="flex justify-end space-x-2">
            <button onclick="closeCellSelectModal()" class="px-4 py-2 border rounded-md">取消</button>
        </div>
    </div>
</div>

<!-- 添加水印选择模态框 -->
<div id="watermarkModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-[500px]">
        <h3 class="text-lg font-medium mb-4">选择水印设置</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">选择水印图片:</label>
                <div id="watermarkList" class="grid grid-cols-4 gap-2 max-h-40 overflow-y-auto">
                    <!-- 水印列表将在这里动态生成 -->
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">选择水印位置:</label>
                <div class="grid grid-cols-3 gap-2">
                    <button class="watermark-position p-2 border rounded" data-position="top-left">左上</button>
                    <button class="watermark-position p-2 border rounded" data-position="top-center">上中</button>
                    <button class="watermark-position p-2 border rounded" data-position="top-right">右上</button>
                    <button class="watermark-position p-2 border rounded" data-position="middle-left">左中</button>
                    <button class="watermark-position p-2 border rounded bg-pink-500 text-white" data-position="center">中心</button>
                    <button class="watermark-position p-2 border rounded" data-position="middle-right">右中</button>
                    <button class="watermark-position p-2 border rounded" data-position="bottom-left">左下</button>
                    <button class="watermark-position p-2 border rounded" data-position="bottom-center">下中</button>
                    <button class="watermark-position p-2 border rounded" data-position="bottom-right">右下</button>
                </div>
            </div>
            <div class="flex justify-end space-x-2">
                <button onclick="closeWatermarkModal()" class="px-4 py-2 border rounded-md">取消</button>
                <button onclick="generateFinalImage()" class="px-4 py-2 bg-pink-500 text-white rounded-md">确定</button>
            </div>
        </div>
    </div>
</div>

<!-- 添加历史记录编辑模态框 -->
<div id="historyEditModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-96">
        <h3 class="text-lg font-medium mb-4">修改内容</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700">剧名</label>
                <input type="text" id="historyTitleInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">划重点</label>
                <input type="text" id="historyHighlightInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
            </div>
            <div class="flex justify-end space-x-2">
                <button onclick="closeHistoryEditModal()" class="px-4 py-2 border rounded-md">取消</button>
                <button onclick="saveHistoryEdit()" class="px-4 py-2 bg-pink-500 text-white rounded-md">保存</button>
            </div>
        </div>
    </div>
</div>

<script>
    let currentEditingCell = null;
    let gridData = [];
    let pendingHistoryItem = null; // 存储待应用的历史记录项
    let currentTemplate = null;

    // 添加 IndexedDB 相关代码
    const dbName = 'gridHistoryDB';
    const storeName = 'history';
    let db;

    // 添加水印相关变量
    let selectedWatermark = null;
    let selectedPosition = 'center';
    const watermarkStoreName = 'watermarks';

    // 添加历史记录编辑相关变量和函数
    let currentEditingHistory = null;

    // 修改 initDB 函数
    async function initDB() {
        return new Promise((resolve, reject) => {
            // 检查浏览器是否支持 IndexedDB
            if (!window.indexedDB) {
                console.error('您的浏览器不支持 IndexedDB');
                // 如果不支持 IndexedDB，尝试删除可能损坏的数据库
                const delRequest = window.indexedDB.deleteDatabase(dbName);
                delRequest.onsuccess = () => {
                    console.log('已删除可能损坏的数据库');
                };
                reject(new Error('浏览器不支持 IndexedDB'));
                return;
            }

            // 尝试删除可能损坏的数据库
            const deleteRequest = window.indexedDB.deleteDatabase(dbName);
            deleteRequest.onsuccess = () => {
                console.log('成功删除旧数据库，准备重新创建');
                
                // 重新打开数据库
                const request = indexedDB.open(dbName, 2);

                request.onerror = (event) => {
                    console.error('数据库打开失败:', event.target.error);
                    reject(event.target.error);
                };

                request.onblocked = (event) => {
                    console.error('数据库被阻塞:', event);
                    // 尝试关闭所有其他打开的数据库连接
                    if (db) {
                        db.close();
                    }
                    reject(new Error('数据库被阻塞'));
                };

                request.onupgradeneeded = (event) => {
                    console.log('数据库升级中...');
                    const db = event.target.result;

                    // 创建历史记录存储
                    if (!db.objectStoreNames.contains(storeName)) {
                        const store = db.createObjectStore(storeName, { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp');
                        store.createIndex('filename', 'filename');
                        console.log('历史记录存储创建成功');
                    }

                    // 创建水印存储
                    if (!db.objectStoreNames.contains(watermarkStoreName)) {
                        const watermarkStore = db.createObjectStore(watermarkStoreName, { keyPath: 'id' });
                        watermarkStore.createIndex('filename', 'filename');
                        console.log('水印存储创建成功');
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('数据库初始化成功');

                    // 添加错误处理
                    db.onerror = (event) => {
                        console.error('数据库错误:', event.target.error);
                    };

                    // 添加版本变更处理
                    db.onversionchange = () => {
                        db.close();
                        console.log('数据库版本已更改，请刷新页面');
                        alert('数据库版本已更改，请刷新页面');
                    };

                    resolve(db);
                };
            };

            deleteRequest.onerror = (event) => {
                console.error('删除旧数据库失败:', event.target.error);
                // 即使删除失败，也尝试继续打开数据库
                const request = indexedDB.open(dbName, 2);
                // ... 相同的打开数据库逻辑 ...
            };
        });
    }

    // 添加数据库状态检查函数
    async function ensureDBConnection() {
        if (!db) {
            console.log('数据库连接不存在，尝试重新初始化...');
            try {
                await initDB();
            } catch (error) {
                console.error('数据库重新初始化失败:', error);
                // 如果初始化失败，使用 localStorage 作为临时存储
                alert('数据库初始化失败，将使用临时存储。请刷新页面重试。');
            }
        }
        return db;
    }

    function initializeGrid(size) {
        const container = document.getElementById('gridContainer');
        // 设置容器样式为等比缩放
        container.style.width = '100%';
        container.style.maxWidth = '1000px'; // 可以调整最大显示宽度
        container.style.display = 'grid';
        container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        container.style.gap = '0';
        container.innerHTML = '';
        gridData = [];

        for (let i = 0; i < size * size; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.innerHTML = `
                    <div class="flex items-center justify-center h-full">
                        <span class="text-gray-400">点击添加内容</span>
                    </div>
                `;
            cell.addEventListener('click', () => openEditModal(i));
            container.appendChild(cell);
            gridData[i] = null;
        }
    }

    function openEditModal(index) {
        currentEditingCell = index;
        document.getElementById('editModal').classList.remove('hidden');

        // 清空所有输入和预览
        document.getElementById('imageInput').value = '';
        document.getElementById('titleInput').value = '';
        document.getElementById('actorInput').value = '';
        document.getElementById('highlightInput').value = '';
        document.getElementById('imagePreviewContainer').innerHTML = '';

        // 如果已有数据，填充表单
        if (gridData[index]) {
            document.getElementById('titleInput').value = gridData[index].title || '';
            document.getElementById('actorInput').value = gridData[index].actor || '';
            document.getElementById('highlightInput').value = gridData[index].highlight || '';

            // 显示已有图片预览
            if (gridData[index].image) {
                const previewContainer = document.getElementById('imagePreviewContainer');
                previewContainer.innerHTML = `
                        <img src="${gridData[index].image}" class="mt-2 max-w-full h-32 object-contain">
                    `;
            }
        }
    }

    function closeEditModal() {
        document.getElementById('editModal').classList.add('hidden');
        currentEditingCell = null;
        // 清空表单
        document.getElementById('imageInput').value = '';
        document.getElementById('titleInput').value = '';
        document.getElementById('actorInput').value = '';
        document.getElementById('highlightInput').value = '';
    }

    // 修改 generatePreviewImage 函数
    async function generatePreviewImage(data) {
        const FIXED_SIZE = 720;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = FIXED_SIZE;
        canvas.height = FIXED_SIZE;

        // 绘制白色背景
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, FIXED_SIZE, FIXED_SIZE);

        // 加载并绘制图片
        const img = new Image();
        img.crossOrigin = 'anonymous';

        try {
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = data.image;
            });

            // 计算图片绘制尺寸
            // 强制宽度为720，高度按比例计算
            const scale = FIXED_SIZE / img.width;
            const drawWidth = FIXED_SIZE;
            const drawHeight = img.height * scale;
            const drawX = 0;
            const drawY = 0; // 靠上对齐

            // 绘制图片
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            // 设置文字阴影效果
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // 绘制文字
            ctx.fillStyle = 'white';
            const fontSize = FIXED_SIZE * 0.06;
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textBaseline = 'top';

            // 绘制演员名称 - 右对齐，保留右侧间距
            const actorText = `★ ${data.actor || ''}`;
            const actorMetrics = ctx.measureText(actorText);
            ctx.fillText(actorText, FIXED_SIZE - FIXED_SIZE * 0.05 - actorMetrics.width, FIXED_SIZE * 0.08);

            // 绘制搜索关键词 - 只在有关键词时才显示
            if (data.searchKeyword) {
                ctx.fillStyle = 'white';
                ctx.fillText('跨克嗖索[', FIXED_SIZE * 0.05, FIXED_SIZE * 0.05);

                // 计算前缀文本宽度
                const prefixWidth = ctx.measureText('跨克嗖索[').width;

                // 绘制关键词部分（红色）
                ctx.fillStyle = '#ff4444';
                ctx.fillText(data.searchKeyword, FIXED_SIZE * 0.05 + prefixWidth, FIXED_SIZE * 0.05);

                // 绘制后缀括号（白色）
                ctx.fillStyle = 'white';
                const keywordWidth = ctx.measureText(data.searchKeyword).width;
                ctx.fillText(']', FIXED_SIZE * 0.05 + prefixWidth + keywordWidth, FIXED_SIZE * 0.05);
            }

            // 绘制剧名 - 向上移动位置
            ctx.font = `bold ${FIXED_SIZE * 0.1}px sans-serif`;
            ctx.fillText(data.title || '', FIXED_SIZE * 0.05, FIXED_SIZE * 0.65); // 从0.75改为0.7

            // 绘制划重点 - 支持多行文本
            ctx.fillStyle = '#ff4444';
            ctx.font = `${FIXED_SIZE * 0.05}px sans-serif`;
            const highlightText = `划重点：${data.highlight || ''}`;
            const maxWidth = FIXED_SIZE * 0.9; // 最大宽度为90%的画布宽度
            const lineHeight = FIXED_SIZE * 0.06; // 行高
            const startY = FIXED_SIZE * 0.78; // 从0.85改为0.78，增加与剧名的间距

            // 文本换行处理函数
            function wrapText(text, x, y, maxWidth, lineHeight) {
                const words = text.split('');
                let line = '';
                let y0 = y;

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n];
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;

                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line, x, y0);
                        line = words[n];
                        y0 += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x, y0);
            }

            // 应用文本换行
            wrapText(highlightText, FIXED_SIZE * 0.05, startY, maxWidth, lineHeight);

            // 在绘制完所有文字后，清除阴影设置
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            return canvas.toDataURL('image/jpeg', 0.8);
        } catch (error) {
            console.error('图片生成失败:', error);
            return null;
        }
    }

    // 修改 updateCell 函数
    async function updateCell(index, data, saveToHistory = true) {
        const cell = document.getElementById('gridContainer').children[index];

        // 生成预览图片
        const previewImageUrl = await generatePreviewImage(data);

        if (previewImageUrl) {
            cell.innerHTML = `
                    <div class="image-container">
                        <img src="${previewImageUrl}" draggable="false">
                    </div>
                `;

            // 如果需要保存到历史记录，使用 saveToHistory
            if (saveToHistory) {
                delete data.shouldSaveToHistory;
                await saveToHistory(data);
            }
        } else {
            cell.innerHTML = `
                    <div class="flex items-center justify-center h-full">
                        <span class="text-gray-400">图片加载失败</span>
                    </div>
                `;
        }

        cell.addEventListener('click', () => openEditModal(index));
    }

    // 修改 saveToHistory 函数
    async function saveToHistory(data) {
        const database = await ensureDBConnection();
        if (!database) {
            console.error('无法保存到历史记录：数据库未连接');
            return;
        }

        return new Promise((resolve, reject) => {
            const transaction = database.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);

            const historyItem = {
                ...data,
                id: Date.now() + Math.random(),
                timestamp: new Date().toISOString(),
                actor: data.actor || '',
                filename: data.filename || ''
            };

            const request = store.add(historyItem);
            request.onsuccess = () => resolve(historyItem);
            request.onerror = () => reject(request.error);
        });
    }

    // 获取所有历史记录
    async function getAllHistory() {
        const database = await ensureDBConnection();
        if (!database) {
            console.error('无法获取历史记录：数据库未连接');
            return [];
        }

        return new Promise((resolve, reject) => {
            const transaction = database.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.index('timestamp').getAll();

            request.onsuccess = () => {
                const results = request.result.reverse(); // 最新的记录在前面
                console.log('获取到的历史记录数量:', results.length);
                resolve(results);
            };
            request.onerror = () => {
                console.error('获取历史记录失败:', request.error);
                reject(request.error);
            };
        });
    }

    // 删除历史记录
    async function deleteHistoryItem(id) {
        const database = await ensureDBConnection();
        if (!database) {
            console.error('无法删除历史记录：数据库未连接');
            return;
        }

        return new Promise((resolve, reject) => {
            const transaction = database.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(id);

            request.onsuccess = () => {
                updateHistoryDisplay();
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }

    // 修改 updateHistoryDisplay 函数
    async function updateHistoryDisplay() {
        try {
            const container = document.getElementById('historyContainer');
            const history = await getAllHistory();
            console.log('获取到的历史记录:', history);

            // 按文件名前缀分组
            const groups = groupHistoryByPrefix(history);
            console.log('分组后的历史记录:', groups);

            // 生成分组标题行
            container.innerHTML = `
                <div class="col-span-full grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-2 mb-4">
                    ${Object.entries(groups).map(([prefix, items]) => `
                        <div 
                            class="group-header cursor-pointer bg-gray-50 p-2 rounded hover:bg-gray-100 transition-colors"
                            onclick="toggleGroupContent('${prefix.replace(/'/g, "\\'")}')"
                        >
                            <div class="text-sm font-medium text-gray-700">
                                ${prefix} (${items.length}项)
                            </div>
                        </div>
                    `).join('')}
                </div>
                ${Object.entries(groups).map(([prefix, items]) => `
                    <div id="group-${prefix}" class="group-content hidden col-span-full mb-4">
                        <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-2">
                            ${items.map(item => `
                                <div class="relative group cursor-pointer border rounded p-2" onclick="applyHistoryItem(${item.id})">
                                    <div class="flex space-x-2">
                                        <div class="w-12 h-12 flex-shrink-0">
                                            <img src="${item.image}" class="w-full h-full object-cover rounded">
                                        </div>
                                        <div class="flex-1 min-w-0">
                                            <div class="text-sm font-medium truncate">${item.title || ''}</div>
                                            <div class="text-xs text-gray-500 truncate">${item.actor || ''}</div>
                                        </div>
                                    </div>
                                    <div class="absolute top-1 right-1 flex space-x-1">
                                        <button
                                            onclick="event.stopPropagation(); handleEditClick(${item.id})"
                                            class="bg-green-500 text-white rounded-full w-5 h-5 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                                            title="修改"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"/>
                                            </svg>
                                        </button>
                                        <button
                                            onclick="event.stopPropagation(); handleCopyClick(${item.id})"
                                            class="bg-blue-500 text-white rounded-full w-5 h-5 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                                            title="复制"
                                        >
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                                                <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"/>
                                                <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"/>
                                            </svg>
                                        </button>
                                        <button
                                            onclick="event.stopPropagation(); deleteHistoryItem(${item.id})"
                                            class="bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                                            title="删除"
                                        >
                                            ×
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `).join('')}
            `;

            // 自动展开第一个分组
            const firstGroup = Object.keys(groups)[0];
            if (firstGroup) {
                const groupElement = document.getElementById(`group-${firstGroup}`);
                if (groupElement) {
                    groupElement.classList.remove('hidden');
                }
            }

            console.log('历史记录显示更新完成');
        } catch (error) {
            console.error('更新历史记录显示失败:', error);
        }
    }

    // 添加切换分组显示的函数
    function toggleGroupContent(prefix) {
        const groupContent = document.getElementById(`group-${prefix}`);
        if (groupContent) {
            // 隐藏其他所有分组
            document.querySelectorAll('.group-content').forEach(el => {
                if (el.id !== `group-${prefix}`) {
                    el.classList.add('hidden');
                }
            });
            // 切换当前分组的显示状态
            groupContent.classList.toggle('hidden');
        }
    }

    // 添加新的CSS样式
    const style = document.createElement('style');
    style.textContent = `
        /* 组标题样式 */
        .group-header {
            transition: all 0.2s;
            border: 1px solid #e5e7eb;
        }

        .group-header:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* 组内容过渡效果 */
        .group-content {
            transition: all 0.3s ease-in-out;
        }

        .group-content.hidden {
            display: none;
        }

        /* 保持其他现有样式 */
        ${style.textContent}
    `;
    document.head.appendChild(style);

    // 修改 groupHistoryByPrefix 函数
    function groupHistoryByPrefix(history) {
        const groups = {};
        const usedCombinations = new Set(); // 用于记录已使用的演员名称和图片组合

        history.forEach(item => {
            if (!item.filename) return;

            // 获取文件名（不包括扩展名）
            const filename = item.filename;
            const nameWithoutExt = filename.replace(/\.[^/.]+$/, '');
            
            // 创建唯一标识：演员名称 + 图片文件名
            const uniqueKey = `${item.actor || ''}_${nameWithoutExt}`;
            
            // 如果这个组合已经存在，跳过
            if (usedCombinations.has(uniqueKey)) return;
            usedCombinations.add(uniqueKey);

            // 使用演员名称作为分组键
            const groupKey = item.actor || '未分类';

            if (!groups[groupKey]) {
                groups[groupKey] = [];
            }
            groups[groupKey].push(item);
        });

        // 对每个分组内的项目按时间戳排序（最新的在前）
        Object.values(groups).forEach(group => {
            group.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        });

        // 对分组键按字母顺序排序
        const sortedGroups = {};
        Object.keys(groups).sort().forEach(key => {
            sortedGroups[key] = groups[key];
        });

        return sortedGroups;
    }

    // 修改 applyHistoryItem 函数
    async function applyHistoryItem(id) {
        try {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(id);

            request.onsuccess = () => {
                const item = request.result;
                if (!item) return;

                const searchKeyword = document.getElementById('searchKeyword').value;
                const size = parseInt(document.getElementById('gridSize').value);
                const editMode = document.getElementById('editMode').value;

                if (editMode === 'column') {
                    // 列复制模式的逻辑保持不变
                    let emptyColIndex = -1;
                    for (let col = 0; col < size; col++) {
                        if (!gridData[col]) {
                            emptyColIndex = col;
                            break;
                        }
                    }

                    if (emptyColIndex === -1) {
                        showColumnSelectModal({...item, searchKeyword});
                        return;
                    }

                    for (let row = 0; row < size; row++) {
                        const index = row * size + emptyColIndex;
                        gridData[index] = {
                            ...item,
                            searchKeyword,
                            offsetX: 0,
                            offsetY: 0
                        };
                        updateCell(index, gridData[index]);
                    }
                } else {
                    // 格子唯一模式：显示格子选择模态框
                    showCellSelectModal({...item, searchKeyword});
                }
            };

            request.onerror = () => {
                console.error('获取历史记录失败:', request.error);
            };
        } catch (error) {
            console.error('应用历史记录失败:', error);
        }
    }

    // 添加格子选择模态框相关函数
    function showCellSelectModal(historyItem) {
        pendingHistoryItem = historyItem;
        const modal = document.getElementById('cellSelectModal');
        const container = document.getElementById('cellSelectContainer');
        const size = parseInt(document.getElementById('gridSize').value);

        // 设置网格列数
        container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        container.innerHTML = '';

        // 生成格子选项
        for (let i = 0; i < size * size; i++) {
            const row = Math.floor(i / size);
            const col = i % size;
            const data = gridData[i];
            const preview = data ? `
                <div class="flex flex-col items-center">
                    <img src="${data.image}" class="w-12 h-12 object-cover rounded mb-1">
                    <div class="text-xs text-gray-500 truncate w-full text-center">${data.title || ''}</div>
                </div>
            ` : '<div class="text-gray-400">空格</div>';

            container.innerHTML += `
                <div
                    onclick="applyCellHistoryItem(${i})"
                    class="cursor-pointer border rounded p-1 hover:bg-gray-100 aspect-square flex flex-col items-center justify-center"
                >
                    <div class="text-xs font-medium mb-1">格子 ${i + 1}</div>
                    ${preview}
                </div>
            `;
        }

        modal.classList.remove('hidden');
    }

    function closeCellSelectModal() {
        document.getElementById('cellSelectModal').classList.add('hidden');
        pendingHistoryItem = null;
    }

    async function applyCellHistoryItem(index) {
        if (!pendingHistoryItem) return;

        gridData[index] = {
            ...pendingHistoryItem,
            offsetX: 0,
            offsetY: 0
        };
        
        // 更新格子UI
        const cell = document.getElementById('gridContainer').children[index];
        const previewImageUrl = await generatePreviewImage(gridData[index]);
        
        if (previewImageUrl) {
            cell.innerHTML = `
                <div class="image-container">
                    <img src="${previewImageUrl}" draggable="false">
                </div>
            `;
            cell.addEventListener('click', () => openEditModal(index));
        }

        // 更新模态框中的格子预览
        const modalCell = document.getElementById('cellSelectContainer').children[index];
        if (modalCell) {
            modalCell.innerHTML = `
                <div class="text-xs font-medium mb-1">格子 ${index + 1}</div>
                <div class="flex flex-col items-center">
                    <img src="${gridData[index].image}" class="w-12 h-12 object-cover rounded mb-1">
                    <div class="text-xs text-gray-500 truncate w-full text-center">${gridData[index].title || ''}</div>
                </div>
            `;
        }

        closeCellSelectModal();
    }

    // 修改 showColumnSelectModal 函数
    async function showColumnSelectModal(historyItem) {
        pendingHistoryItem = historyItem;
        const modal = document.getElementById('columnSelectModal');
        const container = document.getElementById('columnSelectContainer');
        const size = parseInt(document.getElementById('gridSize').value);

        // 生成列选项
        container.innerHTML = '';
        for (let col = 0; col < size; col++) {
            const firstCellIndex = col;
            const data = gridData[firstCellIndex];
            const preview = data ? `
                    <div class="flex space-x-2">
                        <div class="w-12 h-12 flex-shrink-0">
                            <img src="${data.image}" class="w-full h-full object-cover rounded">
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="text-sm font-medium truncate">${data.title || ''}</div>
                            <div class="text-xs text-gray-500 truncate">${data.actor || ''}</div>
                        </div>
                    </div>
                ` : '<div class="text-gray-400">空列</div>';

            container.innerHTML += `
                    <div
                        onclick="applyHistoryItemToColumn(${col})"
                        class="cursor-pointer border rounded p-2 hover:bg-gray-100"
                    >
                        <div class="text-xs font-medium mb-1">第 ${col + 1} 列</div>
                        ${preview}
                    </div>
                `;
        }

        modal.classList.remove('hidden');
    }

    // 修改 applyHistoryItemToColumn 函数
    async function applyHistoryItemToColumn(colIndex) {
        if (!pendingHistoryItem) return;

        const searchKeyword = document.getElementById('searchKeyword').value;
        const size = parseInt(document.getElementById('gridSize').value);

        // 更新整列数据
        for (let row = 0; row < size; row++) {
            const index = row * size + colIndex;
            gridData[index] = {
                ...pendingHistoryItem,
                searchKeyword,
                offsetX: 0,
                offsetY: 0
            };
            updateCell(index, gridData[index]);
        }

        closeColumnSelectModal();
    }

    function closeColumnSelectModal() {
        document.getElementById('columnSelectModal').classList.add('hidden');
        pendingHistoryItem = null;
    }

    // 添加关键词更新函数
    function updateSearchKeyword(keyword) {
        const size = parseInt(document.getElementById('gridSize').value);
        const totalCells = size * size;

        // 更新所有已有内容的格子
        for (let i = 0; i < totalCells; i++) {
            if (gridData[i]) {
                gridData[i].searchKeyword = keyword;
                updateCell(i, gridData[i]);
            }
        }
    }

    // 修改 saveCell 函数
    async function saveCell() {
        const imageFile = document.getElementById('imageInput').files[0];
        const title = document.getElementById('titleInput').value;
        const actor = document.getElementById('actorInput').value;
        const highlight = document.getElementById('highlightInput').value;
        const searchKeyword = document.getElementById('searchKeyword').value;
        const editMode = document.getElementById('editMode').value;

        // 如果没有选择新图片但有旧数据，保留旧图片
        if (!imageFile && gridData[currentEditingCell]) {
            const updatedData = {
                ...gridData[currentEditingCell],
                title,
                actor,
                highlight,
                searchKeyword
            };

            // 先保存到历史记录（只保存一次）
            if (updatedData.shouldSaveToHistory) {
                delete updatedData.shouldSaveToHistory;
                await saveToHistory(updatedData);
            }

            if (editMode === 'column') {
                // 列复制模式：更新整列数据
                const size = parseInt(document.getElementById('gridSize').value);
                const colIndex = currentEditingCell % size;
                for (let row = 0; row < size; row++) {
                    const index = row * size + colIndex;
                    gridData[index] = {...updatedData};
                    await updateCell(index, gridData[index], false);
                }
            } else {
                // 格子唯一模式：只更新当前格子
                gridData[currentEditingCell] = {...updatedData};
                await updateCell(currentEditingCell, gridData[currentEditingCell], false);
            }

            closeEditModal();
            return;
        }

        if (!imageFile) {
            alert('请选择图片');
            return;
        }

        const reader = new FileReader();
        reader.onload = async function(e) {
            const newData = {
                image: e.target.result,
                title,
                actor,
                highlight,
                searchKeyword,
                filename: imageFile.name,
                offsetX: 0,
                offsetY: 0
            };

            // 先保存到历史记录（只保存一次）
            await saveToHistory(newData);

            if (editMode === 'column') {
                // 列复制模式：更新整列数据
                const size = parseInt(document.getElementById('gridSize').value);
                const colIndex = currentEditingCell % size;
                for (let row = 0; row < size; row++) {
                    const index = row * size + colIndex;
                    gridData[index] = {...newData};
                    await updateCell(index, gridData[index], false);
                }
            } else {
                // 格子唯一模式：只更新当前格子
                gridData[currentEditingCell] = {...newData};
                await updateCell(currentEditingCell, gridData[currentEditingCell], false);
            }

            closeEditModal();
        };
        reader.readAsDataURL(imageFile);
    }

    // 修改图片预览处理函数
    document.getElementById('imageInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const previewContainer = document.getElementById('imagePreviewContainer');
                previewContainer.innerHTML = ''; // 清空现有预览
                const preview = document.createElement('img');
                preview.src = e.target.result;
                preview.className = 'mt-2 max-w-full h-32 object-contain';
                previewContainer.appendChild(preview);
            };
            reader.readAsDataURL(file);
        }
    });

    // 初始化事件监听
    document.getElementById('gridSize').addEventListener('change', (e) => {
        initializeGrid(parseInt(e.target.value));
    });

    document.getElementById('cancelEdit').addEventListener('click', closeEditModal);
    document.getElementById('saveEdit').addEventListener('click', saveCell);

    // 修改生成图片的函数
    async function generateGridImage() {
        const size = parseInt(document.getElementById('gridSize').value);
        const promises = [];

        // 收集所有格子的预览图片生成Promise
        for (let i = 0; i < size * size; i++) {
            if (gridData[i]) {
                promises.push(generatePreviewImage(gridData[i]));
            }
        }

        // 等待所有预览图片生成完成
        const previewImages = await Promise.all(promises);

        // 创建最终的画布
        const CELL_SIZE = 720; // 每个格子的大小与预览图片一致
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = CELL_SIZE * size;
        canvas.height = CELL_SIZE * size;

        // 绘制白色背景
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 将预览图片绘制到对应位置
        let imageIndex = 0;
        for (let i = 0; i < size * size; i++) {
            if (gridData[i]) {
                const row = Math.floor(i / size);
                const col = i % size;
                const x = col * CELL_SIZE;
                const y = row * CELL_SIZE;

                const img = new Image();
                await new Promise((resolve) => {
                    img.onload = resolve;
                    img.src = previewImages[imageIndex];
                });

                ctx.drawImage(img, x, y, CELL_SIZE, CELL_SIZE);
                imageIndex++;
            }
        }

        // 导出图片
        const link = document.createElement('a');
        link.download = `grid-${Date.now()}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.8);
        link.click();
    }

    // 添加数据迁移函数
    async function migrateFromLocalStorage() {
        try {
            // 检查是否已经迁移过（可以通过localStorage中的一个标志来检查）
            if (localStorage.getItem('migrated') === 'true') {
                return;
            }

            // 获取localStorage中的历史记录
            const oldHistory = JSON.parse(localStorage.getItem('gridHistory') || '[]');

            if (oldHistory.length > 0) {
                // 确保数据库已初始化
                if (!db) await initDB();

                // 开始迁移数据
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);

                // 使用Promise.all来并行处理所有迁移操作
                await Promise.all(oldHistory.map(item => {
                    return new Promise((resolve, reject) => {
                        // 确保每个项目都有必要的字段
                        const migratedItem = {
                            ...item,
                            id: item.id || Date.now() + Math.random(),
                            timestamp: item.timestamp || new Date().toISOString()
                        };

                        const request = store.add(migratedItem);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }));

                // 迁移完成后，清除localStorage中的旧数据
                localStorage.removeItem('gridHistory');
                // 设置迁移完成标志
                localStorage.setItem('migrated', 'true');

                console.log(`成功迁移 ${oldHistory.length} 条历史记录到 IndexedDB`);
            }
        } catch (error) {
            console.error('数据迁移失败:', error);
        }
    }

    // 修改初始化代码，添加迁移步骤
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            console.log('页面加载，开始初始化数据库...');
            await initDB();
            console.log('数据库初始化完成，开始更新显示...');
            await updateHistoryDisplay();
            console.log('初始化完成');
        } catch (error) {
            console.error('初始化失败:', error);
            alert('初始化失败，请刷新页面重试');
        }
    });

    // 初始化4x4网格
    initializeGrid(4);

    // 修改生成图片按钮的事件监听器
    document.getElementById('generateImage').addEventListener('click', () => {
        // 移除旧的事件监听器
        document.getElementById('generateImage').removeEventListener('click', generateGridImage);
        // 显示水印选择模态框
        showWatermarkModal();
    });

    // 修改 showWatermarkModal 函数，确保正确显示水印列表
    async function showWatermarkModal() {
        const modal = document.getElementById('watermarkModal');
        modal.classList.remove('hidden');
        
        // 更新水印列表
        await updateWatermarkList();
        
        // 重新绑定水印位置选择事件
        document.querySelectorAll('.watermark-position').forEach(btn => {
            // 移除旧的事件监听器
            btn.replaceWith(btn.cloneNode(true));
        });
        
        // 添加新的事件监听器
        document.querySelectorAll('.watermark-position').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.watermark-position').forEach(b => {
                    b.classList.remove('bg-pink-500', 'text-white');
                });
                e.target.classList.add('bg-pink-500', 'text-white');
                selectedPosition = e.target.dataset.position;
            });
        });
    }

    // 修改 updateWatermarkList 函数，确保 ID 正确传递
    async function updateWatermarkList() {
        try {
            const watermarks = await getAllWatermarks();
            console.log('获取到的水印列表:', watermarks);
            
            const container = document.getElementById('watermarkList');
            if (!container) {
                console.error('未找到水印列表容器');
                return;
            }
            
            // 添加一个取消选择的选项
            container.innerHTML = `
                <div class="watermark-item cursor-pointer border rounded p-2 ${!selectedWatermark ? 'border-pink-500' : ''}"
                     onclick="selectWatermark(null)">
                    <div class="h-16 flex items-center justify-center text-gray-500">
                        不使用水印
                    </div>
                    <div class="text-xs text-center truncate mt-1">无水印</div>
                </div>
            ` + watermarks.map(watermark => `
                <div class="watermark-item cursor-pointer border rounded p-2 ${selectedWatermark?.id === watermark.id ? 'border-pink-500' : ''}"
                     onclick="selectWatermark(${watermark.id})">
                <img src="${watermark.image}" class="w-full h-16 object-contain">
                <div class="text-xs text-center truncate mt-1">${watermark.filename}</div>
                </div>
            `).join('');
            
            console.log('水印列表已更新');
        } catch (error) {
            console.error('更新水印列表失败:', error);
        }
    }

    // 修改 selectWatermark 函数，支持取消选择
    window.selectWatermark = async function(id) {
        try {
            console.log('尝试选择水印，ID:', id);
            
            if (id === null) {
                selectedWatermark = null;
                console.log('已取消选择水印');
            } else {
                const watermarks = await getAllWatermarks();
                console.log('可用的水印列表:', watermarks);
                
                selectedWatermark = watermarks.find(w => w.id === id);
                console.log('找到的水印:', selectedWatermark);
                
                if (!selectedWatermark) {
                    console.error('未找到对应ID的水印:', id);
                    return;
                }
            }
            
            await updateWatermarkList();
            console.log('水印选择完成，当前选中:', selectedWatermark);
        } catch (error) {
            console.error('选择水印失败:', error);
        }
    };

    // 修改 handleWatermarkUpload 函数，使用整数 ID
    async function handleWatermarkUpload(event) {
        try {
            const files = Array.from(event.target.files);
            console.log('选择的文件:', files);
            
            const existingWatermarks = await getAllWatermarks();
            const existingFilenames = new Set(existingWatermarks.map(w => w.filename));
            
            for (const file of files) {
                if (existingFilenames.has(file.name)) {
                    console.log(`跳过重复水印: ${file.name}`);
                    continue;
                }
                
                const imageDataUrl = await readFileAsDataURL(file);
                await saveWatermark({
                    id: Date.now(), // 移除 Math.random()，只使用时间戳
                    filename: file.name,
                    image: imageDataUrl
                });
                console.log(`水印已保存: ${file.name}`);
            }
            
            await updateWatermarkList();
            console.log('水印列表已更新完成');
        } catch (error) {
            console.error('处理水印上传失败:', error);
        }
    }

    // 辅助函数：读取文件为DataURL
    function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    // 修改随机组合函数名和逻辑
    async function randomCombineFromAllGroups() {
        try {
            const history = await getAllHistory();
            const editMode = document.getElementById('editMode').value;
            const size = parseInt(document.getElementById('gridSize').value);
            const searchKeyword = document.getElementById('searchKeyword').value;

            if (history.length === 0) {
                alert('没有可用的数据进行随机组合');
                return;
            }

            // 清空现有数据
            gridData = new Array(size * size).fill(null);

            if (editMode === 'column') {
                // 列复制模式：按分组随机选择
                const groups = groupHistoryByPrefix(history);
                const groupNames = Object.keys(groups);
                
                if (groupNames.length === 0) return;

                // 随机选择最多4个不同的分组
                const selectedGroups = shuffle(groupNames).slice(0, 4);
                const selectedItems = selectedGroups.map(groupName => {
                    const groupItems = groups[groupName] || [];
                    return groupItems[Math.floor(Math.random() * groupItems.length)];
                }).filter(item => item);

                // 填充列数据
                selectedItems.forEach((item, index) => {
                    if (index < size) {
                        for (let row = 0; row < size; row++) {
                            const cellIndex = row * size + index;
                            gridData[cellIndex] = {
                                ...item,
                                searchKeyword,
                                offsetX: 0,
                                offsetY: 0
                            };
                            updateCell(cellIndex, gridData[cellIndex], false);
                        }
                    }
                });
            } else {
                // 格子唯一模式：从所有历史记录中随机选择
                const totalCells = size * size;
                
                // 如果历史记录不够，就循环使用
                let availableItems = [...history];
                while (availableItems.length < totalCells) {
                    availableItems = [...availableItems, ...history];
                }
                
                // 随机打乱所有可用项目
                availableItems = shuffle(availableItems);

                // 填充每个格子
                for (let i = 0; i < totalCells; i++) {
                    const item = availableItems[i];
                    gridData[i] = {
                        ...item,
                        searchKeyword,
                        offsetX: 0,
                        offsetY: 0
                    };
                    updateCell(i, gridData[i], false);
                }
            }

        } catch (error) {
            console.error('随机组合失败:', error);
            alert('随机组合失败，请重试');
        }
    }

    // 数组随机打乱函数
    function shuffle(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }

    // 保存水印到IndexedDB
    async function saveWatermark(watermark) {
        const database = await ensureDBConnection();
        if (!database) {
            console.error('无法保存水印：数据库未连接');
            return;
        }
        return new Promise((resolve, reject) => {
            const transaction = database.transaction([watermarkStoreName], 'readwrite');
            const store = transaction.objectStore(watermarkStoreName);
            console.log('正在保存水印:', watermark);
            const request = store.add(watermark);
            request.onsuccess = () => {
                console.log('水印保存成功:', watermark.id);
                resolve(watermark);
            };
            request.onerror = () => {
                console.error('水印保存失败:', request.error);
                reject(request.error);
            };
        });
    }

    // 获取所有水印
    async function getAllWatermarks() {
        const database = await ensureDBConnection();
        if (!database) {
            console.error('无法获取水印：数据库未连接');
            return [];
        }
        return new Promise((resolve, reject) => {
            const transaction = database.transaction([watermarkStoreName], 'readonly');
            const store = transaction.objectStore(watermarkStoreName);
            const request = store.getAll();
            request.onsuccess = () => {
                console.log('获取所有水印成功:', request.result);
                resolve(request.result);
            };
            request.onerror = () => {
                console.error('获取水印失败:', request.error);
                reject(request.error);
            };
        });
    }

    // 处理编辑按钮点击
    async function handleEditClick(id) {
        try {
            console.log('开始编辑历史记录:', id);
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(id);

            request.onsuccess = () => {
                const item = request.result;
                if (!item) {
                    console.error('未找到历史记录:', id);
                    return;
                }

                console.log('获取到历史记录:', item);
                currentEditingHistory = item;
                
                // 填充表单
                const titleInput = document.getElementById('historyTitleInput');
                const highlightInput = document.getElementById('historyHighlightInput');
                
                titleInput.value = item.title || '';
                highlightInput.value = item.highlight || '';
                
                console.log('表单已填充:', {
                    title: titleInput.value,
                    highlight: highlightInput.value
                });

                // 显示模态框
                document.getElementById('historyEditModal').classList.remove('hidden');
            };

            request.onerror = (error) => {
                console.error('获取历史记录失败:', error);
            };
        } catch (error) {
            console.error('编辑历史记录失败:', error);
        }
    }

    // 关闭历史记录编辑模态框
    function closeHistoryEditModal() {
        document.getElementById('historyEditModal').classList.add('hidden');
        currentEditingHistory = null;
    }

    // 修改 saveHistoryEdit 函数
    async function saveHistoryEdit() {
        if (!currentEditingHistory) {
            console.error('没有正在编辑的历史记录');
            return;
        }

        try {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);

            // 先获取最新的记录
            const getRequest = store.get(currentEditingHistory.id);

            getRequest.onsuccess = async () => {
                const currentRecord = getRequest.result;
                if (!currentRecord) {
                    console.error('未找到要编辑的记录');
                    return;
                }

                // 更新历史记录
                const updatedItem = {
                    ...currentRecord, // 保留所有原有属性
                    title: document.getElementById('historyTitleInput').value,
                    highlight: document.getElementById('historyHighlightInput').value,
                    timestamp: new Date().toISOString() // 更新时间戳
                };

                // 执行更新
                const putRequest = store.put(updatedItem);

                putRequest.onsuccess = async () => {
                    console.log('历史记录更新成功:', updatedItem);
                    
                    // 更新显示
                    await updateHistoryDisplay();
                    
                    // 更新当前网格中的相关格子
                    const size = parseInt(document.getElementById('gridSize').value);
                    for (let i = 0; i < size * size; i++) {
                        if (gridData[i] && gridData[i].id === currentEditingHistory.id) {
                            gridData[i] = {...updatedItem};
                            await updateCell(i, gridData[i], false);
                        }
                    }
                    
                    // 关闭模态框
                    closeHistoryEditModal();
                };

                putRequest.onerror = (error) => {
                    console.error('更新历史记录失败:', error);
                    alert('保存失败，请重试');
                };
            };

            getRequest.onerror = (error) => {
                console.error('获取历史记录失败:', error);
                alert('保存失败，请重试');
            };

            // 添加事务完成的处理
            transaction.oncomplete = () => {
                console.log('事务完成');
            };

            transaction.onerror = (error) => {
                console.error('事务失败:', error);
                alert('保存失败，请重试');
            };

        } catch (error) {
            console.error('保存编辑失败:', error);
            alert('保存失败，请重试');
        }
    }
</script>

<style>
    /* 确保导出时的图片比例正确 */
    #gridContainer {
        aspect-ratio: 1;
    }

    #gridContainer > div {
        aspect-ratio: 1;
        border: none;
        margin: 0;
        padding: 0;
    }

    .image-container {
        position: relative;
        overflow: hidden;
        padding-bottom: 100%; /* 保持1:1比例 */
    }

    .image-container img {
        transition: transform 0.1s ease-out;
        will-change: transform;
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform-origin: center center; /* 确保变换以中心点为基准 */
    }

    /* 确保导出时的元素位置正确 */
    #gridContainer .absolute {
        position: absolute !important;
    }

    /* 优化跨克嗖索样式 */
    #gridContainer .bg-white {
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
    }

    #gridContainer .bg-white span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        height: 100%;
    }

    /* 确保文字不会有额外的行高影响垂直居中 */
    #gridContainer .leading-none {
        line-height: 1 !important;
    }

    /* 历史记录和列选择样式 */
    #historyContainer > div,
    #columnSelectContainer > div {
        background-color: white;
        transition: all 0.2s;
    }

    #historyContainer > div:hover,
    #columnSelectContainer > div:hover {
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* 图片预览容器样式 */
    #historyContainer img,
    #columnSelectContainer img {
        object-fit: cover;
        width: 100%;
        height: 100%;
    }

    /* 添加文字阴影效果，提高可读性 */
    .drop-shadow-lg {
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    /* 优化下划线样式 */
    .underline {
        text-decoration-thickness: 1px;
        text-underline-offset: 2px;
    }

    /* 添加文字发光效果 */
    .glow-text {
        text-shadow: 0 0 10px rgba(255, 0, 0, 0.8),
        0 0 20px rgba(255, 0, 0, 0.8),
        0 0 30px rgba(255, 0, 0, 0.8);
        font-weight: 600;
        color: white;
    }

    /* 添加格子选择模态框样式 */
    #cellSelectContainer {
        max-height: 70vh;
        overflow-y: auto;
    }

    /* 添加水印相关样式 */
    .watermark-item {
        transition: all 0.2s;
    }

    .watermark-item:hover {
        border-color: #ec4899;
    }

    .watermark-position {
        transition: all 0.2s;
    }

    .watermark-position:hover {
        background-color: #fdf2f8;
    }
</style>
</body>
</html>
